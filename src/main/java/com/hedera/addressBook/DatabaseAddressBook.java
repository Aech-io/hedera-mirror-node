package com.hedera.addressBook;

/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import com.hedera.configLoader.ConfigLoader;
import lombok.extern.log4j.Log4j2;

import com.hederahashgraph.api.proto.java.NodeAddressBook;

import java.io.FileOutputStream;

/**
 * This is a utility file to read back service record file generated by Hedera node
 */
@Log4j2
public class DatabaseAddressBook {

	private static PreparedStatement sqlGetMaxTransaction;
	private static PreparedStatement sqlGetAllFileData;

    public static void saveToDisk(Connection connect) throws Exception {

        // get the max transaction ID for a file update on 102
        ResultSet resultSet;
        long transactionId = 0;
        
		try {
			
			sqlGetMaxTransaction = connect.prepareStatement("SELECT MAX(t.id)" + 
					" FROM t_transactions t" + 
					"    ,t_transaction_types tt" + 
					"    ,t_entities e" + 
					"    ,t_entity_types et" + 
					" WHERE t.fk_trans_type_id = tt.id" + 
					" AND   t.fk_cud_entity_id = e.id" + 
					" AND   e.entity_num = 102" + 
					" AND   e.entity_realm = 0" + 
					" AND   e.entity_shard = 0" + 
					" AND   e.fk_entity_type_id = et.id" + 
					" AND   tt.name = 'FILEUPDATE'" + 
					" AND   et.name = 'file'");

			sqlGetAllFileData = connect.prepareStatement("SELECT fd.file_data" + 
					" FROM t_transactions t" + 
					"    ,t_transaction_types tt" + 
					"    ,t_entities e" + 
					"    ,t_entity_types et" + 
					"    ,t_file_data fd" + 
					" WHERE t.fk_trans_type_id = tt.id" + 
					" AND   t.fk_cud_entity_id = e.id" + 
					" AND   e.entity_num = 102" + 
					" AND   e.entity_realm = 0" + 
					" AND   e.entity_shard = 0" + 
					" AND   e.fk_entity_type_id = et.id" + 
					" AND   fd.fk_trans_id = t.id" + 
					" AND   tt.name IN ('FILEUPDATE','FILEAPPEND')" + 
					" AND   et.name = 'file'" + 
					" AND   t.id >= ?" + 
					" ORDER BY fd.fk_trans_id;");
			
			resultSet = sqlGetMaxTransaction.executeQuery();

	        while (resultSet.next()) {
	        	transactionId = resultSet.getLong(1);
	        }
	        resultSet.close();
	        sqlGetMaxTransaction.close();
	        
	        if (transactionId == 0) {
	        	log.error("Unable to locate address book update transaction");
	        	throw new Exception("Unable to locate address book update transaction");
	        }
	        
	        sqlGetAllFileData.setLong(1, transactionId);
	        resultSet = sqlGetAllFileData.executeQuery();
	        byte[] addressBookBytes = new byte[0];
	        while (resultSet.next()) {
	        	byte[] fileChunk = resultSet.getBytes(1);
	        	byte[] newBytes = Arrays.copyOf(addressBookBytes, addressBookBytes.length + fileChunk.length);
	        	System.arraycopy(fileChunk, 0, newBytes, addressBookBytes.length, fileChunk.length);
	        	addressBookBytes = newBytes;
	        }
	        resultSet.close();
	        sqlGetAllFileData.close();
			
    		NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);

            FileOutputStream fos = new FileOutputStream(ConfigLoader.getAddressBookFile());
            fos.write(addressBookBytes);
            fos.close();
            log.info("Address book file {} updated from transactions", () -> ConfigLoader.getAddressBookFile());

		} catch (SQLException e) {
            log.error("Unable to fetch address book data for entity 0.0.102 from database", e);
			throw e;
    	} catch (Exception e) {
    		log.warn("Unable to parse incomplete address book - awaiting further transactions");
    	}
    }
}


